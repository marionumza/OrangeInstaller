#encoding: utf-8
from OpenOrange import *
from JabberControl import JabberControl
import time
import threading
import mutex
from thread import allocate_lock
from ChatTools import ChatClientEngineBinding, reduceTo127

class ChatClientListener(CThread):
    
    def __str__(self):
        return "LISTENER %i" % id(self)

    def __repr__(self):
        return "LISTENER %i" % id(self)
    
    def acquireLock(self,wait=True):
        self.__lock.acquire(wait)

    def releaseLock(self):
        self.__lock.release ()

    def run(self):
        self.__lock = allocate_lock()
        self.setName(findWindow(self.windowid).getTitle())
        while self.keep:
            time.sleep(0.3)
            if not self.keep: return 
            window = findWindow(self.windowid)  
            if not window: break               
            window.acquireLock()
            ce = window.getEngine() #getChatClient()
            if ce.isConnected(): 
                ce.process(1)
                window.updateUserInterface()
            window.releaseLock()
            
            
ParentChatClientWindow = SuperClass("ChatClientWindow","Window",__file__)
class ChatClientWindow(ParentChatClientWindow,ChatClientEngineBinding):
    __listeners = {} # listado de threads (CThread) por window id
    __LocksList = {} # listado de locks (por ventana) ordenado por window id
    __LocksListLock = allocate_lock() # lock general de la lista de locks 
    __ChatEngineList = {} # diccionario de objectos engine, ordenado por window id
    __eid=None

    #ChatClientEngineBinding INTERFACES 
    def getEngineId (self):
        #if self.getId() in ChatClientWindow.__ChatEngineIds.keys():
        #    return ChatClientWindow.__ChatEngineIds[self.getId()]
        #else:
        #    print "excepcion obteniendo engine id"
        #    print "KEYS: " + "-".join(ChatClientWindow.__ChatEngineIds.keys())
        #    return None
        #return ChatClientWindow.__eid
        return self.getRecord().RunningChatEngineCode

    def setEngineId (self,eid):
        ChatClientWindow.__eid=eid
        r = self.getRecord()
        r.RunningChatEngineCode=eid
        self.setRecord(r)

    def setEngine(self,engine):
        if self.getId() in ChatClientWindow.__ChatEngineList.keys():
            ChatClientWindow.__ChatEngineList.pop(self.getId())
        if engine:
            ChatClientWindow.__ChatEngineList[self.getId()]=engine

    def getEngine(self):
        ret=None
        if self.getId() in ChatClientWindow.__ChatEngineList.keys():
            ret =ChatClientWindow.__ChatEngineList[self.getId()]
        if ret: 
            ret.setWindowId(self.getId())
            if self.getEngineId():
                ret.setId(self.getEngineId())
        #print "retornando ngine %s" % str(ret)
        return ret

    def linkEngine(self,engine):
        #engine.pause()
        engine.setWindowId(self.getId())
        engine.setUpdateUserInterfaceCallBack(self.updateUserInterface)
        engine.setUnsubscriptionActionCallBack(self.unsubscriptionAction)
        engine.setSubscriptionActionCallBack(self.subscriptionAction)
        engine.setSaveMessageCallBack(self.saveMessage)
        #engine.resume()
        return engine

    def acquireLock(self,wait=True):
        if not self.getId() in ChatClientWindow.__LocksList.keys():
            ChatClientWindow.__LocksListLock.acquire()
            if not self.getId() in ChatClientWindow.__LocksList.keys(): 
                ChatClientWindow.__LocksList[self.getId()] = allocate_lock()
            ChatClientWindow.__LocksListLock.release()
        ChatClientWindow.__LocksList[self.getId()].acquire(wait)#umm, tal vez halla que ver bien este wait,
                                                                #tal vez tambien tendría que afectar a los
                                                                #otros acquires()
    def releaseLock(self):
        if ChatClientWindow.__LocksList[self.getId()].locked():
            ChatClientWindow.__LocksList[self.getId()].release()
    #app 
    #feo, elije entre: iso-8859-1 y utf-8.
    _enc = None
    def getCurrentEncoding (self):
        if not self._enc:
            if len('ñ') == 1:
                self._enc = 'ISO-8859-1'
            else:
                self._enc = 'UTF-8'
        return self._enc

    # para anlizar un string que venga desde el gui.
    def getOpenOrangeEncoding (self): 
        return self.jaData.getEncoding ()

    def getListener(self):
        return ChatClientWindow.__listeners.get(self.getId(), None)

    def setListener(self,listener):
        oldlistener = self.getListener()
        if oldlistener:
            oldlistener.keep = False
            #while oldlistener.running():
            #    time.sleep(0.1)
            #    print "waiting finnish"
            ChatClientWindow.__listeners.pop(self.getId())
        if listener:
            ChatClientWindow.__listeners[self.getId()] = listener 

    def externalInit(self, jabberAccountCode, engine, engineId):
        engine.acquire() # bloqueo para poder pelear contra el thread de la rutina
        #para conocer acerca del siguiente ver metodo saveMessage(self).
        self.firstUpdateUserIface=False
        self.setEngineId(engineId)
        self.afterEdit("JabberAccountCode")
        self.afterShowRecord()
        self.linkEngine(engine)
        self.setEngine(engine)
        self.processEvent("Connected")
        r = self.getRecord()
        r.ContinueInBackground=True
        self.setRecord(r)
        engine.release ()

    def showVisualAlert (self):
        self.seccond = 0

    def hideVisualAlert (self):
        try:
            del self.seccond
        except AttributeError, e:
            pass

    def getTitle (self):
        seccond = 0
        if hasattr(self, "seccond"):
            seccond = self.seccond
            self.seccond+=1
        seccond %= 2
        if seccond == 0:
            title = "Cliente de Chat"
        else:
            title = ""
        return title

    def afterEdit(self, fieldname):
        if fieldname == "Message":
            record = self.getRecord()
            to = record.SelectedUserName
            if not to: return
            msg = record.Message
            msg = msg.decode(self.getOpenOrangeEncoding(), "replace")
            self.send(to,msg) #OK
            record.Message=""
            record.setFocusOnField("Message")
            self.hideVisualAlert ()
        elif fieldname == "JabberAccountCode":
            self.initAccountData()
        elif fieldname == "Status":
            if not self.isConnected():
                message(tr("OpenOrange could not establish a connection with the server"))
            spec = self.getRecord()
            if spec.Status:
                contactsReport = self.getContactsReport()
                # si tenemos contactos enganados acerca de nuestra precencia, tenemos que
                # enviar nuestro nuevo estado por separado a cada contacto de nuestra
                # lista.
                # En caso contrario, enviamos el estado a todos (llamar changeStatus sin 
                # poner un destino)
                self.acquireLock()
                if contactsReport.hasDeceivedContacts():
                    contactList = contactsReport.getContactList()
                    for contactEntry in contactList:
                        if not contactEntry.isDeveived():
                            self.changeStatus(spec.Status,contactEntry.getId())
                else: 
                    self.changeStatus(spec.Status)
                self.releaseLock()

    def afterShowRecord(self):
        if not self.getEngine():
            self.startNewEngine()
        record = self.getRecord()
        from ChatConversationReport import ChatConversationReport
        conversation = ChatConversationReport()
        reportview = self.getReportView("Conversation")
        conversation.setView(reportview)
        conversation.open(False)
        self.getRecord().ConversationReportId = conversation.getId()
        from ChatContactsReport import ChatContactsReport
        contacts = ChatContactsReport()
        contacts.init (self)
        reportview = self.getReportView("Contacts")
        contacts.setView(reportview)
        #contacts.open(False) ERROR !, esto hay que hacerlo despues de 
        # setearle a contacts todos los datos de instancia que queremos
        # que persistan. Por algun motivo si hago contacts.open () aca
        # todos los datos que le setee a contacts luego no persisten
        self.getRecord().ContactsReportId = contacts.getId()        
        contacts.window = self
        contacts.open(False)
        r = self.getRecord()
        r.ContinueInBackground=False
        self.setRecord(r)

    def buttonClicked(self, buttonname):
        if buttonname == "Connect":
            r = self.getRecord()
            from JabberAccount import JabberAccount
            if not JabberAccount.exists(r.JabberAccountCode):
                message(tr('Invalid Jabber account'))
                return 
            if self.isChatDaemonRunning ():
                #print "calling takeEngine ()"
                if self.takeEngine ():
                    return
            self.startNewEngine()
            accountData =  self.getRecord()
            #if accountData.UseSSL: 
            #    self.startNegociation(accountData.ServerHost,SecurityLevel='ssl',Port=5223)
            #else:
            #    self.startNegociation(accountData.ServerHost)
            self.startNegociation(accountData.ServerHost)
            self.logIn(accountData.UserName,accountData.Password,accountData.Resource)
            if accountData.Status:
                self.changeStatus(accountData.Status)
            self.processEvent("Connected")
        elif buttonname == "Disconnect":
            if not self.disconnectAtClose ():
                alert ("No puede desconectarse mientras se ejecuta la rutina de Chat.")
                return
            cr = self.getContactsReport()
            if cr: cr.setOffline()
            self.acquireLock()
            self.disconnect()
            self.releaseLock()
            self.stopGui()
        elif buttonname == "AddContact":
            spec = self.getRecord()
            if not self.isConnected():
                message(tr("OpenOrange could not establish a connection with the server"))
                return
            if spec.SelectedUserName:               
                self.acquireLock()
                self.addContact(spec.SelectedUserName)
                self.releaseLock()
                message ("Se le envio una solicitud a %s" % str(spec.SelectedUserName))
        elif buttonname == "DelContact":
            spec = self.getRecord()
            self.delContact(spec.SelectedUserName)

    def filterPasteWindow(self, fieldname):
        if fieldname == "JabberAccountCode":
            return "{UserCode} = s|%s|" % currentUser ()

    def delContact(self,selectedUserName):
        if not self.isConnected():
            message(tr("OpenOrange could not establish a connection with the server"))
            return
        if selectedUserName:                
            message = tr("Are you sure you want to delete this register?") + " " + selectedUserName
            if askYesNo(message) == 1: 
                self.acquireLock()
                self.removeContact(selectedUserName)
                self.releaseLock()

    def processEvent(self,eventName):
        accountData = self.getRecord()
        if eventName == "Connected":
            cr = self.getContactsReport()
            if cr: 
                cr.setOnline ()
                jid = accountData.UserName + "@" + accountData.ServerHost + "/" + accountData.Resource
                cr.setAccount (jid)
            self.startListener ()

    def isChatDaemonRunning (self):
        from ChatDaemonRoutine import ChatDaemonThread
        r = self.getRecord ()
        if not r: return False
        engine = ChatDaemonThread.Engines.get (r.JabberAccountCode)
        if not engine: 
            #print "LISTADO DE ENGINES "
            for k in ChatDaemonThread.Engines.keys ():
                #print "clave %s" % k
                pass
            return False
        return True

    def takeEngine (self):
        from ChatDaemonRoutine import ChatDaemonThread
        r = self.getRecord ()
        engineId = r.JabberAccountCode
        engine = ChatDaemonThread.Engines.get (engineId)
        if not engine:
            return False
        return self.externalInit(r.JabberAccountCode, engine, engineId)
            
    def editContact(self,selectedUserName):
        from JabberContactWindow import JabberContactWindow
        from JabberContact import JabberContact
        jc = JabberContact()
        jc.JId = selectedUserName
        jc.load()
        jcw = JabberContactWindow()
        jcw.setRecord(jc)
        jcw.open()
        
    def setCurrentContact(self, contact):
        conversationReport = self.getConversationReport()
        contactsReport = self.getContactsReport()
        if not conversationReport or not contactsReport:
            return
        self.getRecord().SelectedUserName= contact
        ci = contactsReport.getContactInfo(contact)
        conversationReport.showConversation(ci)
        contactsReport.unsetAlert(contact)
        self.getRecord().setFocusOnField("Message")

    def rosterUpdate(self):
        roster = self.getRoster()
        contactsreport = findReport(self.getRecord().ContactsReportId)
        if not contactsreport: return
        contactsreport.resetContacts()
        from ChatContactsReport import ContactEntry
        from JabberContact import JabberContact
        idlist=[]
        contactsreport.stop()
        for jid in roster.getJIDs():
            strStatus =  reduceTo127(roster.getStatus(jid))
            strjid = reduceTo127(str(jid))
            jc = JabberContact()
            jc.JId = strjid
            contactName = None
            if jc.load():
                contactName = jc.Name
            n = reduceTo127(roster.getName(jid))
            ce = ContactEntry(  id = strjid, name= contactName, 
                                online=reduceTo127(roster.getOnline(jid)),
                                status=reduceTo127(roster.getStatus(jid)))
            contactsreport.addContact(ce)
            idlist.append(ce.getId())
        # limpieza !
        contacts = contactsreport.getContactList()
        for contactEntry in contacts:
            if not contactEntry.getId() in idlist:
                contactsreport.delContact(contactEntry)
        contactsreport.start ()

    def getConversationReport(self):
        return findReport(self.getRecord().ConversationReportId)

    def getContactsReport(self):
        return findReport(self.getRecord().ContactsReportId)

    def getWinDesc(self):
        return "Window <%s>" % str(self.getId())

    def saveMessage(self,strJId,text,**kwargs):
        #parche bastante feo pero efectivo: obliga a cargar el roster antes de
        #mostrar los mensajes, esto arregla el problema de que el contacto
        #se muestra como "desconocido" cuando es el primer mensaje recibido
        #utilizando el ChatDaemon.
        if hasattr (self, "firstUpdateUserIface") and not self.firstUpdateUserIface:
            self.updateUserInterface ()
            self.firstUpdateUserIface = True
        conversation = self.getConversationReport()
        cr = self.getContactsReport()
        #text = reduceTo127(text,"ISO-8859-1") #quita caracteres que no tienen representacion en asccii
        text = reduceTo127(text,self.getCurrentEncoding()) #quita caracteres que no tienen representacion en asccii
        text = text.encode() #lo lleva al encoding por defecto (ascii en openorange)
        if not conversation or not cr: return
        contactId = kwargs.get("conversationHash",strJId)
        res=None
        offset = contactId.find("/")
        if offset > -1: 
            res = contactId[offset:]
            contactId = contactId[0:offset]
        fromUser = strJId
        if fromUser.find("@")>-1: 
            fromUser = contactId
            contactEntry = cr.getContactInfo(contactId)
            conversation.addLine(contactEntry,fromUser, text)
            if self.getRecord().SelectedUserName != contactEntry.getId(): 
                cr.setAlert(contactId)
            self.showVisualAlert ()

    def updateUserInterface(self,roster=None):
        #if roster:
        #    self.setRoster(roster)
        self.rosterUpdate()
        self.setRoster(roster)
        self.refreshTitle ()

    def beforeClose(self):
        self.acquireLock()
        if self.isConnected () and self.disconnectAtClose():
            oldng = self.getEngine()
            self.disconnect()
            oldng.release() # dejamos al trhead de la rutina si es que existe !
        self.stopGui()
        self.setEngine(None)
        self.releaseLock()
        self.setListener(None)  
        return True

    def disconnectAtClose(self):
        return not (self.getEngineId () and self.getRecord ().ContinueInBackground)
        
    def initAccountData(self):
        from JabberAccount import JabberAccount
        record = self.getRecord()
        ja = JabberAccount.bring(record.JabberAccountCode)
        if not ja: 
            return
        #TODO: hacer que se utilize self.jaData en lugar del record de la 
        #ventana, esto era util en el pasado, cuando las ventanas no eran
        #persistentes.
        self.jaData = ja
        data = self.getRecord()
        data.UserName = ja.UserName
        data.Password= ja.Password
        data.Email= ja.Email
        data.ServerHost = ja.Domain
        data.Resource = ja.Resource
        data.UseSSL = ja.UseSSL
        if not data.Status: data.Status = ja.InitialStatus

    def startListener(self):
        listener = ChatClientListener()
        self.setListener(listener)
        listener.windowid = self.getId()
        listener.keep = True
        listener.start()

    def subscriptionAction(self,who):
        jid = str(who)
        cr = self.getContactsReport()
        if cr: cr.addPendingAcceptContact(jid)
        
    def unsubscriptionAction(self,who):
        self.unsubscribe(who) 
        
    def acceptSubscription(self,who):
        self.addContact(who)
        from JabberContact import JabberContact
        jcr = JabberContact()
        jcr.JId = who
        if not jcr.load(): jcr.store()
        from JabberContactWindow import JabberContactWindow
        jcw = JabberContactWindow()
        jcw.setRecord(jcr)
        jcw.open()
        self.getContactsReport().delPendingContact(who)
        
    def denySubscription(self,who):
        self.unsubscribe(who)
        self.getContactsReport().delPendingContact(who)
    
    def disconnect(self):
        ChatClientEngineBinding.stopNegociation(self)
        self.setListener(None)
        #self.acquireLock()
        #self.setEngine(None)
        #self.releaseLock()

    def stopGui(self):
        self.getContactsReport().destructor()     # to fix openorange bug !
        self.getConversationReport().destructor() # to fix openorange bug !
    
